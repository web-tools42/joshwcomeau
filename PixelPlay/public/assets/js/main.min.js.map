{"version":3,"sources":["global/global.ctrl.js","game/game.ctrl.js","game/directives/answer_with_numbers.directive.js","game/services/fetch_cities.service.js","game/services/fetch_photos_from_500px.service.js","game/services/fetch_photos_from_node.service.js","game/services/game_manager.service.js","components/score/score.module.js","components/game/game.module.js","app.routes.js","app.js","score/score.service.js","user/user.service.js","services/preloader.service.js","services/reverse_geocoder.service.js"],"names":[],"mappings":"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","file":"main.min.js","sourcesContent":["function GlobalController($scope, User, GameManager) {\n  var global = this;\n\n  global.manager = GameManager;\n\n  global.currentUser = null;\n  global.userService = User;\n\n  $scope.$on(\"userAuthenticated\", function(e, data) {\n    $scope.$apply(function() {\n      global.currentUser = data;\n      console.log(data);\n    });\n  });\n}\n\n\nGlobalController.$inject = ['$scope', 'User', 'GameManager'];\nangular.module('pixelPlay').controller('GlobalController', ['$scope', 'User', 'GameManager', GlobalController]);","function GameController($scope, GameManager, FetchPhotosFrom500px, bogusAnswers) {\n  this.manager = GameManager;\n  GameManager.countriesAndCities  = bogusAnswers;\n\n  GameManager.initialize();\n  \n}\n\n\n\n\n// Called in app.routes.js before the view is rendered.\nGameController.resolve = {\n  bogusAnswers: ['FetchCities', function(FetchCities) {\n    return FetchCities.query().$promise;\n  }]\n};\n\n\nGameController.$inject = ['$scope', 'GameManager', 'FetchPhotosFrom500px', 'bogusAnswers'];\nangular.module('pixelPlay.game').controller('GameController', ['$scope', 'GameManager', 'FetchPhotosFrom500px', 'bogusAnswers', GameController]);","function answerWithNumbers($document, GameManager) {\n  return {\n    restrict: 'A',\n    link: function() {\n      $document.bind('keyup', function(e) {\n        if ( e.which === 49 ) {\n          $(\"#answer-1\").click();\n          $(\"#answer-1 .number-label\").removeAttr(\"style\");\n        } else if ( e.which === 50 ) {\n          $(\"#answer-2\").click();\n          $(\"#answer-2 .number-label\").removeAttr(\"style\");          \n        } else if ( e.which === 51 ) {\n          $(\"#answer-3\").click();\n          $(\"#answer-3 .number-label\").removeAttr(\"style\");\n        }\n      });\n\n      $document.bind('keydown', function(e) {\n        if ( e.which === 49 ) {\n          $(\"#answer-1 .number-label\").css({ background: '#347b8e'});\n        } else if ( e.which === 50 ) {\n          $(\"#answer-2 .number-label\").css({ background: '#347b8e'});\n        } else if ( e.which === 51 ) {\n          $(\"#answer-3 .number-label\").css({ background: '#347b8e'});\n        }\n      });\n    }\n  };\n}\n\n\nangular.module('pixelPlay').directive('answerWithNumbers', ['$document', 'GameManager', answerWithNumbers]);","function FetchCities($resource) {\n  return $resource('/api/cities');\n}\n\nangular.module('pixelPlay.game').factory(\"FetchCities\", [\"$resource\", FetchCities]);","function FetchPhotosFrom500px($q) {\n  return {\n    allPhotos:      [],\n    filteredPhotos: [],\n    maxSizePhotos:  [],\n\n    photos:         [],\n\n    query: function(givenOpts, winWidth) {\n      console.log(\"wheee\");\n      var \n      deferred = $q.defer(),\n      defaultOpts = {\n        feature:    'fresh_today',\n        only:       'Urban Exploration',\n        image_size: 5,\n        rpp:        100\n      },\n      opts = _.merge(defaultOpts, givenOpts);\n      _this    = this;\n\n      _500px.api('/photos', opts, function (response) {\n        if (response.success) {\n          _this.allPhotos = response.data.photos;\n          _this.photos    = _this.appropriateForGame(response.data.photos);\n          \n\n          // Grab the XL ones if our window is bigger than 1200.\n          if ( winWidth > 1200 )\n            _this.photos = _this.getMaxSize(_this.photos);\n\n          deferred.resolve({\n            success: true\n          });\n        } else {\n          deferred.reject({\n            success:  false,\n            status:   response.status,\n            message:  response.error_message\n          });\n        }\n      });\n\n      return deferred.promise;\n    },\n\n    // We need to strip out the photos that aren't well suited for our game.\n    // Needs to have location coordinates, at least 1200px wide, and landscape orientation.\n    appropriateForGame: function(photos) {\n      return _.filter(photos, function(photo) {\n        return (\n          photo.latitude !== null && \n          photo.longitude !== null &&\n          photo.width >= 1200 &&\n          photo.width > photo.height &&\n          photo.width <= (photo.height * 2)\n        );\n      });\n    },\n\n    getMaxSize: function(photos) {\n      console.log(\"maxSize\");\n      return _.map(photos, function(photo) {\n        photo.image_url = photo.image_url.substr(0, photo.image_url.length-5) + \"2048.jpg\";\n        return photo;\n      });\n    }\n  };\n}\n\nangular.module('pixelPlay.game').factory(\"FetchPhotosFrom500px\", [\"$q\", FetchPhotosFrom500px]);","function FetchPhotosFromNode($q) {\n  return {\n    allPhotos:      [],\n    filteredPhotos: [],\n    maxSizePhotos:  [],\n\n    photos:         [],\n\n    query: function(givenOpts) {\n      // console.log(\"Querying\");\n      // var \n      // deferred = $q.defer(),\n      // defaultOpts = {\n      //   feature:    'fresh_today',\n      //   only:       'Urban Exploration',\n      //   image_size: 5,\n      //   rpp:        100\n      // },\n      // opts = _.merge(defaultOpts, givenOpts);\n      // _this    = this;\n\n      // _500px.api('/photos', opts, function (response) {\n      //   if (response.success) {\n      //     _this.allPhotos      = response.data.photos;\n      //     _this.filteredPhotos = _this.appropriateForGame(response.data.photos);\n      //     _this.maxSizePhotos  = _this.getMaxSize(_this.filteredPhotos);\n\n      //     _this.photos         = _this.maxSizePhotos;\n\n      //     deferred.resolve({\n      //       success: true\n      //     });\n      //   } else {\n      //     deferred.reject({\n      //       success:  false,\n      //       status:   response.status,\n      //       message:  response.error_message\n      //     });\n      //   }\n      // });\n\n      // return deferred.promise;\n    },\n\n    // We need to strip out the photos that aren't well suited for our game.\n    // Needs to have location coordinates, at least 1200px wide, and landscape orientation.\n    appropriateForGame: function(photos) {\n      return _.filter(photos, function(photo) {\n        return (\n          photo.latitude !== null && \n          photo.longitude !== null &&\n          photo.width >= 1200 &&\n          photo.width > photo.height &&\n          photo.width <= (photo.height * 2)\n        );\n      });\n    },\n\n    getMaxSize: function(photos) {\n      console.log(\"maxSize\");\n      return _.map(photos, function(photo) {\n        photo.image_url = photo.image_url.substr(0, photo.image_url.length-5) + \"2048.jpg\";\n        return photo;\n      });\n    }\n  };\n}\n\nangular.module('pixelPlay.game').factory(\"FetchPhotosFromNode\", [\"$q\", FetchPhotosFromNode]);","function GameManager($interval, $timeout, $q, FetchPhotosFrom500px, FetchCities, Preloader, ReverseGeocoder) { \n  var manager = this;\n\n  this.initialize = function() {\n    // Provided from GameController\n    // this.countriesAndCities;\n\n\n    this.score = 0;\n    this.combo = 0;\n\n    this.winWidth = $(window).width();\n\n    this.photos           = [];\n    this.loadedPhotos     = [];\n    this.currentPhoto     = null;\n    this.currentAnswers   = null;\n    this.currentQuestion  = 0;\n    this.chosenAnswer     = null;\n    this.page             = 1;\n\n    this.preloadsLeft     = 3; // initial images to preload\n    this.loadPercent      = 0;\n    this.loadPieces       = 5; // 1 at the start, 1 for the server request, and 3 images to preload.\n\n    this.resultsSplash    = null;\n\n    \n\n    this.states = {\n      initial:  0,\n      loading:  1,\n      waiting:  2,\n      running:  3,\n      finished: 4,\n      error:    5\n    };\n\n    this.state = this.states.initial;\n\n    // Possible modes are 'fresh' and 'curated'\n    this.mode  = null;\n  };\n\n  this.selectMode = function(mode) {\n    console.log(\"SELECTING MODE \", mode)\n    if (mode === 'fresh' && manager.state === manager.states.initial) {\n      manager.updateLoadBar();\n      FetchPhotosFrom500px.query({}, this.winWidth)\n        .then(function(result) {\n          manager.photos = FetchPhotosFrom500px.photos;\n          manager.preloadQuestion(manager.numToPreload);\n          manager.updateLoadBar();\n        });\n\n      manager.state = manager.states.loading;\n    }\n  };\n\n  this.startGame = function() {\n    manager.state = manager.states.running;\n  };\n\n  // Our images are loaded and we're ready to go.\n  // Set it up so that the user can click 'start'.\n  this.setupGame = function() {\n    manager.currentPhoto   = manager.loadedPhotos.shift();\n    manager.currentAnswers = manager.buildAnswers();\n    manager.state          = manager.states.waiting;\n  };\n\n  this.updateLoadBar = function() {\n    this.loadPercent += (1 / manager.loadPieces) * 100;\n  };\n\n\n  this.preloadQuestion = function() {\n    var pauseLength       = 350,\n        question, startTime;\n\n\n    startTime = new Date().getTime();\n    question = manager.photos[0];\n\n    console.log(\"Calling to preload, with this many left: \", manager.preloadsLeft);\n\n    $q.all({\n      getImage:    Preloader.preloadImages([question]), \n      getLocation: ReverseGeocoder.getLocation(question)\n    }).then(function(results) {\n\n      question.location = results.getLocation.location;\n\n      // Move our photo into the loaded queue, remove from the photos array.\n      manager.loadedPhotos.push(question);\n      manager.photos.shift();\n\n      if (manager.preloadsLeft > 0)\n        manager.preloadsLeft--;\n\n      manager.updateLoadBar();\n\n\n      // Alright, here's the magic.\n      // If this is our final iteration, currentIteration should == iterations.\n      // IF that's true, all of our preloading is done.\n      // Otherwise, we'll need to figure out how much time we have left to wait,\n      // set a timeout, and re-invoke this function.\n\n      if ( manager.preloadsLeft ) {\n        manager.waitAndPreloadAnother(startTime, pauseLength);\n      } else {\n        // Is this our initial load? If so, set up the game.\n        if ( manager.state === manager.states.loading )\n          manager.setupGame();\n      }\n    }, function(results) {\n      // Something went wrong, so we want to skip this question and load a new one.\n      manager.photos.shift();\n      manager.waitAndPreloadAnother(startTime, pauseLength);\n    });\n  }\n\n  this.waitAndPreloadAnother = function(startTime, pauseLength) {\n    var endTime, iterationLength, timeLeftToWait;\n    endTime = new Date().getTime();\n    iterationLength = endTime - startTime;\n    if ( iterationLength < pauseLength ) {\n      timeLeftToWait = pauseLength - iterationLength;\n      $timeout(manager.preloadQuestion, timeLeftToWait);\n    } else {\n      manager.preloadQuestion();\n    }\n  };\n\n  this.submitAnswer = function(ans) {\n    if ( this.resultsSplash === null ) {\n      this.chosenAnswer = ans;\n      if ( this.currentPhoto.location.city === ans.city ) {\n        // They got it right!\n        this.score++;\n        this.combo++;\n        this.resultsSplash = true;\n      } else {\n        this.resultsSplash = false;\n        this.combo = 0;\n      }\n\n      // preload another question.\n      this.preloadQuestion();\n\n      // Fetch more questions from 500px, if necessary (or available)\n      if (this.photos.length < 10) {\n        this.page++;\n        FetchPhotosFrom500px.query({page: this.page})\n        .then(function(result) {\n          _.forEach(FetchPhotosFrom500px.filteredPhotos, function(photo) {\n            manager.photos.push(photo);\n          });\n        });\n      }\n\n      $timeout(function() {\n        manager.currentPhoto = manager.loadedPhotos.shift();  \n        console.log(manager.currentPhoto);\n      }, 150);\n    }\n\n  };  \n\n  this.goToNextQuestion = function() {\n    this.chosenAnswer = null;\n    this.currentQuestion++;\n    this.currentAnswers = this.buildAnswers();\n\n    this.resultsSplash  = null;\n  };\n\n  this.buildAnswers = function() {\n    var pluckedCity1 = this.pickRandomCity(),\n        pluckedCity2 = pluckedCity1;\n\n    this.rightAnswer = this.currentPhoto.location;\n\n    while( pluckedCity1.city === pluckedCity2.city ) {\n      pluckedCity2 = this.pickRandomCity();\n    }\n\n    return _.shuffle([this.rightAnswer, pluckedCity1, pluckedCity2]);\n  };\n\n  this.pickRandomCity = function() {\n    var ans, country, city;\n    ans = _.sample(this.countriesAndCities);\n\n    country = ans.country;\n    city    = _.sample(ans.cities);\n\n    return {\n      country: country,\n      city:    city\n    };\n  };\n\n\n}\n\n\nangular.module('pixelPlay.game').service('GameManager', ['$interval', '$timeout', '$q', 'FetchPhotosFrom500px', 'FetchCities', 'Preloader', 'ReverseGeocoder', GameManager]);\n","angular.module('pixelPlay.score', []);","angular.module(\"pixelPlay.game\", []);","angular.module('appRoutes', []).config(['$routeProvider', '$locationProvider', function($routeProvider, $locationProvider) {\n  $routeProvider\n    .when('/', {\n      templateUrl:  '/components/dashboard/dashboard.index.html'\n    })\n\n    // GAME ===================================================================\n    // GET :index\n    .when('/game', {\n      templateUrl:  '/components/game/game.index.html',\n      controller:   'GameController',\n      controllerAs: 'game',\n      resolve:      GameController.resolve\n    });\n\n\n    $locationProvider.html5Mode(true);\n}]);","angular\n  .module('pixelPlay', ['ngAnimate', 'ngRoute', 'ngResource', 'appRoutes', 'pixelPlay.game', 'pixelPlay.score'])\n  .run(['User', '$rootScope', function(User, $rootScope) {\n    _500px.init({\n      sdk_key: '1e6cd00470800d39b07106a70a650cdf88277901'\n    });\n\n    console.log(\"500px initialized\");\n\n    _500px.getAuthorizationStatus(User.updateUser);\n\n}]);","angular.module('pixelPlay.score').factory(\"Score\", [\"$resource\", function($resource) {\n  return $resource('/api/scores/:id');\n}]);","angular.module('pixelPlay').service('User', ['$rootScope', 'Score', function($rootScope, Score) {\n  var user = this;\n\n  user.currentUser = null;\n  user.data        = null;\n\n\n  user.login = function() {\n    _500px.login(user.updateUser);\n  };\n\n  user.logout = function() {\n    _500px.logout(user.updateUser);\n  };\n\n  // This is passed in as the callback to 500px's getAuthorizationStatus().\n  user.updateUser = function(res) {\n    if ( res === 'authorized' ) {\n      // Cool, we've got their permission. Let's get their user data.\n      _500px.api('/users', function (response) {\n        console.log(response);\n        user.currentUser = response.data.user;\n        user.data        = response;\n        $rootScope.$broadcast('userAuthenticated', response.data.user);\n      });\n    } else {\n      console.log(\"updateUser is logging out\");\n      user.currentUser = user.data = null;\n    }\n  };\n}]);","// Originally written by Ben Nadel (http://www.bennadel.com/blog/2597-preloading-images-in-angularjs-with-promises.htm)\n// Modified by Joshua Comeau\n\nangular.module('pixelPlay')\n.factory(\"Preloader\", ['$q', '$rootScope', function( $q, $rootScope ) {\n\n  // I manage the preloading of image objects. Accepts an array of image URLs.\n  function Preloader( imageLocations ) {\n\n    // Because I'm passing in an array of objects, we need to extract\n    // just the strings for image locations.\n    this.imageLocations = _.map(imageLocations, function(img) {\n      return img.image_url;\n    });\n\n    // As the images load, we'll need to keep track of the load/error\n    // counts when announing the progress on the loading.\n    this.imageCount = this.imageLocations.length;\n    this.loadCount = 0;\n    this.errorCount = 0;\n\n    // I am the possible states that the preloader can be in.\n    this.states = {\n      PENDING: 1,\n      LOADING: 2,\n      RESOLVED: 3,\n      REJECTED: 4\n    };\n\n    // I keep track of the current state of the preloader.\n    this.state = this.states.PENDING;\n\n    // When loading the images, a promise will be returned to indicate\n    // when the loading has completed (and / or progressed).\n    this.deferred = $q.defer();\n    this.promise = this.deferred.promise;\n\n  }\n\n\n  // ---\n  // STATIC METHODS.\n  // ---\n\n\n  // I reload the given images [Array] and return a promise. The promise\n  // will be resolved with the array of image locations.\n  Preloader.preloadImages = function( imageLocations ) {\n\n    var preloader = new Preloader( imageLocations );\n\n    return( preloader.load() );\n\n  };\n\n\n  // ---\n  // INSTANCE METHODS.\n  // ---\n\n\n  Preloader.prototype = {\n\n    // Best practice for \"instanceof\" operator.\n    constructor: Preloader,\n\n\n    // ---\n    // PUBLIC METHODS.\n    // ---\n\n\n    // I determine if the preloader has started loading images yet.\n    isInitiated: function isInitiated() {\n      return( this.state !== this.states.PENDING );\n    },\n\n\n    // I determine if the preloader has failed to load all of the images.\n    isRejected: function isRejected() {\n      return( this.state === this.states.REJECTED );\n    },\n\n\n    // I determine if the preloader has successfully loaded all of the images.\n    isResolved: function isResolved() {\n      return( this.state === this.states.RESOLVED );\n    },\n\n\n    // I initiate the preload of the images. Returns a promise.\n    load: function load() {\n\n        // If the images are already loading, return the existing promise.\n        if ( this.isInitiated() ) {\n          return( this.promise );\n        }\n\n        this.state = this.states.LOADING;\n\n        for ( var i = 0 ; i < this.imageCount ; i++ ) {\n          this.loadImageLocation( this.imageLocations[ i ] );\n        }\n\n        // Return the deferred promise for the load event.\n        return( this.promise );\n\n    },\n\n\n    // ---\n    // PRIVATE METHODS.\n    // ---\n\n\n    // I handle the load-failure of the given image location.\n    handleImageError: function handleImageError( imageLocation ) {\n\n      this.errorCount++;\n\n      // If the preload action has already failed, ignore further action.\n      if ( this.isRejected() ) {\n        return;\n      }\n\n      this.state = this.states.REJECTED;\n\n      this.deferred.reject( imageLocation );\n\n    },\n\n\n    // I handle the load-success of the given image location.\n    handleImageLoad: function handleImageLoad( imageLocation ) {\n\n      this.loadCount++;\n\n      // If the preload action has already failed, ignore further action.\n      if ( this.isRejected() ) {\n        return;\n      }\n\n      // Notify the progress of the overall deferred. This is different\n      // than Resolving the deferred - you can call notify many times\n      // before the ultimate resolution (or rejection) of the deferred.\n      this.deferred.notify({\n        percent: Math.ceil( this.loadCount / this.imageCount * 100 ),\n        imageLocation: imageLocation\n      });\n\n      // If all of the images have loaded, we can resolve the deferred\n      // value that we returned to the calling context.\n      if ( this.loadCount === this.imageCount ) {\n\n        this.state = this.states.RESOLVED;\n\n        this.deferred.resolve( this.imageLocations );\n\n      }\n\n    },\n\n\n    // I load the given image location and then wire the load / error\n    // events back into the preloader instance.\n    // --\n    // NOTE: The load/error events trigger a $digest.\n    loadImageLocation: function loadImageLocation( imageLocation ) {\n\n      var preloader = this;\n\n      // When it comes to creating the image object, it is critical that\n      // we bind the event handlers BEFORE we actually set the image\n      // source. Failure to do so will prevent the events from proper\n      // triggering in some browsers.\n      var image = $( new Image() ).load(\n        function( event ) {\n\n          // Since the load event is asynchronous, we have to\n          // tell AngularJS that something changed.\n          $rootScope.$apply(function() {\n            preloader.handleImageLoad( event.target.src );\n\n            // Clean up object reference to help with the\n            // garbage collection in the closure.\n            preloader = image = event = null;\n\n          });\n\n        }\n      ).error(\n        function( event ) {\n\n          // Since the load event is asynchronous, we have to\n          // tell AngularJS that something changed.\n          $rootScope.$apply(function() {\n\n            preloader.handleImageError( event.target.src );\n\n            // Clean up object reference to help with the\n            // garbage collection in the closure.\n            preloader = image = event = null;\n\n          });\n\n        }\n      ).prop( \"src\", imageLocation );\n\n    }\n\n  };\n\n\n  // Return the factory instance.\n  return( Preloader );\n\n}]);","// Written by Joshua Comeau\n\nangular.module('pixelPlay')\n.factory('ReverseGeocoder', ['$q', '$interval', function($q, $interval) {\n  var pauseLength = 500,\n      geocoder    = new google.maps.Geocoder(),\n      currentLocation, latLng;\n\n\n  var getCityAndCountry = function(geoResults) {\n    var components = geoResults[0].address_components,\n        city = [], \n        country, lat, lng, latLng;\n\n    // In the Maps API, 'localities' are cities. Not all areas have one though.\n    // Localities will be 'unshifted' (pushed to the FRONT)\n    // All administrative_areas will be pushed (to the BACK)\n    // That way, we can just take the first member of the array to act as our city;\n\n    _.forEach(components, function(c) {\n      if ( c.types[0] === 'locality' )\n        city.unshift(c.long_name);\n      else if ( c.types[0].substr(0, 19) === 'administrative_area')\n        city.push(c.long_name);\n      else if ( c.types[0] === 'country' )\n        country = c.long_name;\n    });\n    return {\n      city:     city[0],\n      country:  country\n    };\n  };\n\n  return {\n    getLocation: function(photo_obj) {\n      var lat       = photo_obj.latitude,\n          lng       = photo_obj.longitude,\n          latLng    = new google.maps.LatLng(lat, lng),\n          deferred  = $q.defer(),\n          geocoded_location;\n\n      geocoder.geocode({'latLng': latLng}, function(results, status) {\n        if (status == google.maps.GeocoderStatus.OK) {\n          if (results[1]) {\n            geocoded_location = getCityAndCountry(results);\n\n            if (geocoded_location.city && geocoded_location.country) {\n              deferred.resolve({\n                location: getCityAndCountry(results)\n              });\n            } else {\n              deferred.reject({\n                location: null\n              });\n            }\n          } else {\n            alert('No results found');\n          }\n        } else {\n          alert('Geocoder failed due to: ' + status);\n          deferred.reject({\n            location: null\n          });\n        }\n      });\n\n      return deferred.promise;\n    }\n  };\n}]);"],"sourceRoot":"/source/"}